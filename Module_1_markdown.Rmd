---
title: "D-place FARM documentation: Module 1"
author: "Ty Tuff, Bruno Vilela, and Carlos Botero"
date: 'project began: 15 May 2016, document updated: `r strftime(Sys.time(), format
  = "%d %B %Y")`'
output:
  html_notebook: default
  html_document: default
  pdf_document: default
  word_document: default
bibliography: FARM package.bib
---

# Module 1: Simulation to produce a world and a tree 

```{r}
# Install the most recent version of FARM from a .zip file
install.packages(file.choose(), repos=NULL) 
```

```{r}
library(FARM)
ls("package:FARM")
```

## Inputs
 
```{r}

```


## Module 1 functions
#### The first set of RunSim functions are the default pipeline where only one output is saved at the end of the simulation. 


This first function controls error messages coming from the primary function below. 
```{r}
RunSimUltimate <- function (myWorld, P.extinction, P.speciation, P.diffusion, P.Arisal, 
    P.TakeOver, nbs, independent, N.steps, multiplier, silent = TRUE) 
{
    result <- try(RunSim(myWorld, P.extinction, P.speciation, 
        P.diffusion, P.Arisal, P.TakeOver, nbs, independent, 
        N.steps, multiplier), silent = silent)
    if (class(result) == "try-error") {
        result <- NA
    }
    return(result)
}
#<environment: namespace:FARM>
```

This is the primary function running the simulation.
```{r}
RunSim <- function (myWorld, P.extinction, P.speciation, P.diffusion, P.Arisal, 
    P.TakeOver, nbs, independent, N.steps, multiplier, start = NULL) 
{
    world.size <- nrow(myWorld)
    rootnode <- world.size + 1
    if (is.null(start)) {
        start <- sample(1:world.size, 1)
    }
    myWorld[start, 4:6] <- c(0, 0, 1)
    mytree <- TheOriginOfSpecies(world.size, start)
    myT <- 0
    input <- list(P.speciation, P.Arisal, P.diffusion, P.extinction, 
        P.TakeOver, myWorld, mytree, myT, multiplier, nbs, independent)
    rand_order_func_run <- list("Extinction", "Diffusion", "SpeciationTakeOver", 
        "Arisal")
    cat("0% [")
    for (steps in 1:N.steps) {
        if (steps%%round((N.steps/10)) == 0) {
            cat("-")
        }
        if (steps == N.steps) {
            cat("] 100 %\n")
        }
        rand_order <- sample(rand_order_func_run)
        input <- do.call(rand_order[[1]], list(input = input))
        input <- do.call(rand_order[[2]], list(input = input))
        input <- do.call(rand_order[[3]], list(input = input))
        input <- do.call(rand_order[[4]], list(input = input))
    }
    myWorld <- as.data.frame(input[[6]])
    myWorld[, 8] <- paste0("t", myWorld[, 8])
    mytree <- makePhy(input[[7]])
    mytree$edge.length <- mytree$edge.length/N.steps
    return(list(mytree = mytree, myWorld = myWorld))
}
```


















































#### The second set of RunSim functions save an output each timestep if we want to look at trends through time. We use this to make videos of the simulation running. 
```{r}
RunSimUltimate2 <- function (myWorld, P.extinction, P.speciation, P.diffusion, P.Arisal, 
    P.TakeOver, nbs, independent, N.steps, multiplier, silent = TRUE, 
    count, resolution = seq(1, N.steps, 100), P.Arisal0, start = NULL) 
{
    result <- try(RunSim2(myWorld, P.extinction, P.speciation, 
        P.diffusion, P.Arisal, P.TakeOver, nbs, independent, 
        N.steps, multiplier, count = count, resolution = resolution, 
        P.Arisal0 = P.Arisal0, start), silent = silent)
    if (class(result) == "try-error") {
        result <- NA
    }
    return(result)
}
```


```{r}
RunSim2 <- function (myWorld, P.extinction, P.speciation, P.diffusion, P.Arisal, 
    P.TakeOver, nbs, independent, N.steps, multiplier, count, 
    resolution, P.Arisal0, start = NULL) 
{
    folder <- paste0("./Module_1_outputs/myOut_rep_", formatC(count, 
        width = 2, flag = 0), "_combo_", formatC(count, width = 2, 
        flag = 0), "_", "params", "_P.speciation_", paste(formatC(P.speciation, 
        width = 2, flag = 0), collapse = "_"), "_P.extinction_", 
        paste(formatC(P.extinction, width = 2, flag = 0), collapse = "_"), 
        "_P.diffusion_", paste(formatC(P.diffusion, width = 2, 
            flag = 0), collapse = "_"), "_P.TO_", paste(formatC(P.TakeOver, 
            width = 2, flag = 0), collapse = "_"), "_P.Arisal_", 
        paste(formatC(P.Arisal0, width = 2, flag = 0), collapse = "_"), 
        "_timesteps_", N.steps)
    world.size <- nrow(myWorld)
    rootnode <- world.size + 1
    if (is.null(start)) {
        start <- sample(1:world.size, 1)
    }
    myWorld[start, 4:6] <- c(0, 0, 1)
    mytree <- TheOriginOfSpecies(world.size, start)
    myT <- 0
    input <- list(P.speciation, P.Arisal, P.diffusion, P.extinction, 
        P.TakeOver, myWorld, mytree, myT, multiplier, nbs, independent)
    rand_order_func_run <- list("Extinction", "Diffusion", "SpeciationTakeOver", 
        "Arisal")
    cat("0% [")
    for (steps in 1:N.steps) {
        if (steps%%round((N.steps/10)) == 0) {
            cat("-")
        }
        if (steps == N.steps) {
            cat("] 100 %\n")
        }
        rand_order <- sample(rand_order_func_run)
        input <- do.call(rand_order[[1]], list(input = input))
        input <- do.call(rand_order[[2]], list(input = input))
        input <- do.call(rand_order[[3]], list(input = input))
        input <- do.call(rand_order[[4]], list(input = input))
        if (steps %in% resolution) {
            myWorld <- as.data.frame(input[[6]])
            myWorld[, 8] <- paste0("t", myWorld[, 8])
            if (nrow(na.omit(input[[7]])) > 1) {
                mytree <- makePhy(input[[7]])
            }
            else {
                mytree <- NA
            }
            myOut <- list(mytree = mytree, myWorld = myWorld)
            save(myOut, file = paste0(folder, "_", formatC(steps, 
                10, flag = 0), ".Rdata"))
            stats <- Module_2(myOut)
            save(stats, file = paste0(folder, "_", formatC(steps, 
                10, flag = 0), "_stats", ".Rdata"))
        }
    }
    myWorld <- as.data.frame(input[[6]])
    myWorld[, 8] <- paste0("t", myWorld[, 8])
    mytree <- makePhy(input[[7]])
    mytree$edge.length <- mytree$edge.length/N.steps
    return(list(mytree = mytree, myWorld = myWorld))
}
```



